"""Functions for post-processing imageless annual glare outputs.

Note: These functions will most likely be moved to a separate package in the near future.

"""
import json
import os
from ..writer import _filter_by_pattern


def generate_default_schedule(weekday=None, weekend=None):
    """Create a list of 8760 values based on a daily schedule for weekend and weekday.

    Args:
        weekday: A list of 24 values for each hour of a weekday. The values can
            be 0 or 1.
        weekend: A list of 24 values for each hour of a weekend day. The values can
            be 0 or 1.

    Returns:
        List -- A list of 8760 values for the year.

    """
    weekend = weekend or [0] * 24
    weekday = weekday or \
        [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
    assert len(weekend) == 24, 'Weekend list should be 24 values.'
    assert len(weekday) == 24, 'Weekend list should be 24 values.'
    weekend = [0 if v == 0 else 1 for v in weekend]
    weekday = [0 if v == 0 else 1 for v in weekday]
    all_values = []
    day_counter = 0
    week_counter = 1
    while day_counter < 365:
        day_counter += 1
        if week_counter < 7:
            if week_counter == 1:
                all_values.extend(weekend)
            else:
                all_values.extend(weekday)
            week_counter += 1
        else:
            all_values.extend(weekend)
            week_counter = 1
    return all_values


# TODO: support smaller timesteps - currently this works only for hourly calculations
def filter_schedule_by_hours(sun_up_hours, schedule=None):
    """Filter an annual schedule based on sun up hours.

    Args:
        sun_up_hours: A list of sun up hours as integers.
        schedule: A list of 8760 values for the occupancy schedule.

    Returns:
        A tuple with two values.

        occ_pattern -- A filtered version of the annual schedule that only
            includes the sun-up-hours.

        total_hours -- A number for the total occupied hours of the schedule.
    """
    schedule = schedule or generate_default_schedule()
    occ_pattern = [schedule[int(h)] for h in sun_up_hours]
    return occ_pattern, sum(schedule)


def glare_autonomy_to_file(dgp_file, occ_pattern, output_folder, glare_threshold=0.4,
                           grid_name=None, total_hours=None):
    """Compute glare autonomy for an dgp file and write the results to a folder.

    This function generates 1 file for glare autonomy.

    Args:
        dgp_file: Path to an dgp file generated by Radiance. The dgp file should be
            tab separated and shot NOT have a header. The results for each sensor point
            should be available in a row and and each column should be the daylight
            glare probability value for a sun_up_hour. The number of columns should
            match the number of sun up hours.
        occ_pattern: A list of 0 and 1 values for hours of occupancy.
        output_folder: An output folder where the results will be written to. The folder
            will be created if not exist.
        glare_threshold: A fractional number for the threshold of DGP above which
            conditions are considered to induce glare. Default: 0.4.
        grid_name: An optional name for grid name which will be used to name the output
            files. If None the name of the input file will be used.
        total_hours: An integer for the total number of occupied hours in the
            occupancy schedule. If None, it will be assumed that all of the
            occupied hours are sun-up hours and are already accounted for
            in the the occ_pattern.

    Returns:
        file.ga

    """
    if not os.path.isdir(output_folder):
        os.makedirs(output_folder)

    grid_name = grid_name or os.path.split(dgp_file)[-1][-4:]
    ga = os.path.join(output_folder, 'ga', '%s.ga' % grid_name).replace('\\', '/')

    folder = os.path.dirname(ga)
    if not os.path.isdir(folder):
        os.makedirs(folder)

    with open(dgp_file) as results, open(ga, 'w') as gaf:
        for pt_res in results:
            values = (float(res) for res in pt_res.split())
            gar = _glare_autonomy(values, occ_pattern, glare_threshold, total_hours)
            gaf.write(str(gar) + '\n')

    return ga


def _process_input_folder(folder, filter_pattern):
    """Process an imageless annual glare results folder.

    This returns grids_info and sun-up-hours.
    """
    suh_fp = os.path.join(folder, 'sun-up-hours.txt')
    with open(suh_fp) as suh_file:
        sun_up_hours = [float(hour) for hour in suh_file.readlines()]

    info = os.path.join(folder, 'grids_info.json')
    with open(info) as data_f:
        data = json.load(data_f)

    # filter grids if there is a filtering pattern
    grids = _filter_by_pattern(data, filter=filter_pattern)

    return grids, sun_up_hours


def glare_autonomy_to_folder(
    results_folder, schedule=None, glare_threshold=0.4, grids_filter='*',
    sub_folder='metrics'
        ):
    """Compute annual glare autonomy in a folder and write them in a subfolder.

    This folder is an output folder of imageless annual glare recipe. Folder should 
    include grids_info.json and sun-up-hours.txt - the script uses the list in
    grids_info.json to find the result files for each sensor grid.

    Args:
        results_folder: Results folder.
        schedule: An annual schedule for 8760 hours of the year as a list of values.
        glare_threshold: A fractional number for the threshold of DGP above which 
            conditions are considered to induce glare. Default: 0.4.
        grids_filter: A pattern to filter the grids. By default all the grids will be
            processed.
        sub_folder: An optional relative path for subfolder to copy results files.
            Default: metrics

    Returns:
        str -- Path to results folder.

    """
    grids, sun_up_hours = _process_input_folder(results_folder, grids_filter)
    occ_pattern, total_occ = \
        filter_schedule_by_hours(sun_up_hours=sun_up_hours, schedule=schedule)

    metrics_folder = os.path.join(results_folder, sub_folder)
    if not os.path.isdir(metrics_folder):
        os.makedirs(metrics_folder)

    for grid in grids:
        dgp_file = os.path.join(results_folder, '%s.dgp' % grid['full_id'])
        glare_autonomy_to_file(
            dgp_file, occ_pattern, metrics_folder, glare_threshold,
            grid['full_id'], total_occ
        )

    # copy info.json to all results folders
    grid_info = os.path.join(metrics_folder, 'ga', 'grids_info.json')
    with open(grid_info, 'w') as outf:
        json.dump(grids, outf)

    # create info for available results. This file will be used by honeybee-vtk for
    # results visualization
    config_file = os.path.join(metrics_folder, 'config.json')

    cfg = _annual_glare_config()

    with open(config_file, 'w') as outf:
        json.dump(cfg, outf)

    return metrics_folder


def _glare_autonomy(values, occ_pattern, glare_threshold, total_hours):
    """Calculate annual glare autonomy for a sensor.

    Args:
        values: Hourly illuminance values as numbers.
        occ_pattern: A list of 0 and 1 values for hours of occupancy.
        glare_threshold: A fractional number for the threshold of DGP above which
            conditions are considered to induce glare. Default: 0.4.
        total_occupied_hours: An integer for the total number of occupied hours,
            which can be used to avoid having to sum occ pattern each time.

    Returns:
        glare autonomy
    """
    def _percentage(in_v, occ_hours):
        return round(100.0 * in_v / occ_hours, 2)

    ga = 0

    for is_occ, value in zip(occ_pattern, values):
        if is_occ == 0:
            continue
        if value < glare_threshold:
            ga += 1

    return _percentage(ga, total_hours)


def _annual_glare_config():
    """Return vtk-config for imageless annual glare."""
    cfg = {
        "data": [
            {
                "identifier": "Glare autonomy",
                "object_type": "grid",
                "unit": "Percentage",
                "path": "ga",
                "hide": False,
                "legend_parameters": {
                    "hide_legend": False,
                    "min": 0,
                    "max": 100,
                    "color_set": "original",
                    "label_parameters": {
                        "color": [34, 247, 10],
                        "size": 0,
                        "bold": True,
                    },
                },
            },
        ]
    }

    return cfg
